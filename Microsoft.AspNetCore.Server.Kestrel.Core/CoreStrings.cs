using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http2;
using System;
using System.Collections.Generic;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Text;

namespace Microsoft.AspNetCore.Server.Kestrel.Core
{
    internal static class CoreStrings
    {
        internal static string BadRequest = "Bad request.";
        internal static string BadRequest_BadChunkSizeData = "Bad chunk size data.";
        internal static string BadRequest_BadChunkSuffix = "Bad chunk suffix.";
        internal static string BadRequest_ChunkedRequestIncomplete = "Chunked request incomplete.";
        internal static string FormatBadRequest_FinalTransferCodingNotChunked(string detail) => $"The message body length cannot be determined because the final transfer coding was set to '{detail}' instead of 'chunked'.";
        internal static string BadRequest_HeadersExceedMaxTotalSize = "Request headers too long.";
        internal static string BadRequest_InvalidCharactersInHeaderName = "Invalid characters in header name.";
        internal static string FormatBadRequest_InvalidContentLength_Detail(string detail) => $"Invalid content length: {detail}";
        internal static string BadRequest_InvalidHostHeader = "Invalid Host header.";
        internal static string FormatBadRequest_InvalidHostHeader_Detail(string detail) => $"Invalid Host header: '{detail}'";
        internal static string BadRequest_InvalidRequestHeadersNoCRLF = "Invalid request headers: missing final CRLF in header fields.";
        internal static string FormatBadRequest_InvalidRequestHeader_Detail(string detail) => $"Invalid request header: '{detail}'";
        internal static string BadRequest_InvalidRequestLine = "Invalid request line.";
        internal static string FormatBadRequest_InvalidRequestLine_Detail(string detail) => $"Invalid request line: '{detail}'";
        internal static string FormatBadRequest_InvalidRequestTarget_Detail(string detail) => $"Invalid request target: '{detail}'";
        internal static string FormatBadRequest_LengthRequired(string detail) => $"{detail} request contains no Content-Length or Transfer-Encoding header.";
        internal static string FormatBadRequest_LengthRequiredHttp10(string detail) => $"{detail} request contains no Content-Length header.";
        internal static string BadRequest_MalformedRequestInvalidHeaders = "Malformed request: invalid headers.";
        internal static string BadRequest_MethodNotAllowed = "Method not allowed.";
        internal static string BadRequest_MissingHostHeader = "Request is missing Host header.";
        internal static string BadRequest_MultipleContentLengths = "Multiple Content-Length headers.";
        internal static string BadRequest_MultipleHostHeaders = "Multiple Host headers.";
        internal static string BadRequest_RequestLineTooLong = "Request line too long.";
        internal static string BadRequest_RequestHeadersTimeout = "Reading the request headers timed out.";
        internal static string BadRequest_TooManyHeaders = "Request contains too many headers.";
        internal static string BadRequest_UnexpectedEndOfRequestContent = "Unexpected end of request content.";
        internal static string FormatBadRequest_UnrecognizedHTTPVersion(string detail) => $"Unrecognized HTTP version: '{detail}'";
        internal static string BadRequest_UpgradeRequestCannotHavePayload = "Requests with 'Connection: Upgrade' cannot have content in the request body.";
        internal static string FormatFallbackToIPv4Any(int port) => $"Failed to bind to http://[::]:{port} (IPv6Any). Attempting to bind to http://0.0.0.0:{port} instead.";
        internal static string ResponseStreamWasUpgraded = "Cannot write to response body after connection has been upgraded.";
        internal static string BigEndianNotSupported = "Kestrel does not support big-endian architectures.";
        internal static string FormatMaxRequestBufferSmallerThanRequestHeaderBuffer(long requestBufferSize, int requestHeaderSize) => $"Maximum request buffer size ({requestBufferSize}) must be greater than or equal to maximum request header size ({requestHeaderSize}).";
        internal static string FormatMaxRequestBufferSmallerThanRequestLineBuffer(long requestBufferSize, int requestLineSize) => $"Maximum request buffer size ({requestBufferSize}) must be greater than or equal to maximum request line size ({requestLineSize}).";
        internal static string ServerAlreadyStarted = "Server has already started.";
        internal static string UnknownTransportMode = "Unknown transport mode: '{mode}'.";
        internal static string FormatInvalidAsciiOrControlChar(string character) => $"Invalid non-ASCII or control character in header: {character}";
        internal static string FormatInvalidContentLength_InvalidNumber(long value) => $"Invalid Content-Length: \"{value}\". Value must be a positive integral number.";
        internal static string FormatInvalidContentLength_InvalidNumber(string value) => $"Invalid Content-Length: \"{value}\". Value must be a positive integral number.";
        internal static string NonNegativeNumberOrNullRequired = "Value must be null or a non-negative number.";
        internal static string NonNegativeNumberRequired = "Value must be a non-negative number.";
        internal static string PositiveNumberRequired = "Value must be a positive number.";
        internal static string PositiveNumberOrNullRequired = "Value must be null or a positive number.";
        internal static string UnixSocketPathMustBeAbsolute = "Unix socket path must be absolute.";
        internal static string FormatAddressBindingFailed(string address) => $"Failed to bind to address {address}.";
        internal static string BindingToDefaultAddress = "No listening endpoints were configured. Binding to {address} by default.";
        internal static string ConfigureHttpsFromMethodCall = "HTTPS endpoints can only be configured using {methodName}.";
        internal static string FormatConfigurePathBaseFromMethodCall(string methodName) => $"A path base can only be configured using {methodName}.";
        internal static string DynamicPortOnLocalhostNotSupported = "Dynamic port binding is not supported when binding to localhost. You must either bind to 127.0.0.1:0 or [::1]:0, or both.";
        internal static string FormatEndpointAlreadyInUse(ListenOptions endpoint) => $"Failed to bind to address {endpoint}: address already in use.";
        internal static string InvalidUrl = "Invalid URL: '{url}'.";
        internal static string NetworkInterfaceBindingFailed = "Unable to bind to {address} on the {interfaceName} interface: '{error}'.";
        internal static string OverridingWithKestrelOptions = "Overriding address(es) '{addresses}'. Binding to endpoints defined in {methodName} instead.";
        internal static string OverridingWithPreferHostingUrls = "Overriding endpoints defined in UseKestrel() because {settingName} is set to true. Binding to address(es) '{addresses}' instead.";
        internal static string FormatUnsupportedAddressScheme(string address) => $"Unrecognized scheme in server address '{address}'. Only 'http://' is supported.";
        internal static string HeadersAreReadOnly = "Headers are read-only, response has already started.";
        internal static string KeyAlreadyExists = "An item with the same key has already been added.";
        internal static string FormatHeaderNotAllowedOnResponse(string name, int statusCode) => $"Setting the header {name} is not allowed on responses with status code {statusCode}.";
        internal static string FormatParameterReadOnlyAfterResponseStarted(string name) => $"{name} cannot be set because the response has already started.";
        internal static string RequestProcessingAborted = "Request processing didn't complete within the shutdown timeout.";
        internal static string FormatTooFewBytesWritten(long written, long expected) => $"Response Content-Length mismatch: too few bytes written ({written} of {expected}).";
        internal static string FormatTooManyBytesWritten(long written, long expected) => $"Response Content-Length mismatch: too many bytes written ({written} of {expected}).";
        internal static string UnhandledApplicationException = "The response has been aborted due to an unhandled application exception.";
        internal static string FormatWritingToResponseBodyNotSupported(int statusCode) => $"Writing to the response body is invalid for responses with status code {statusCode}.";
        internal static string ConnectionShutdownError = "Connection shutdown abnormally.";
        internal static string RequestProcessingEndError = "Connection processing ended abnormally.";
        internal static string CannotUpgradeNonUpgradableRequest = "Cannot upgrade a non-upgradable request. Check IHttpUpgradeFeature.IsUpgradableRequest to determine if a request can be upgraded.";
        internal static string UpgradedConnectionLimitReached = "Request cannot be upgraded because the server has already opened the maximum number of upgraded connections.";
        internal static string UpgradeCannotBeCalledMultipleTimes = "IHttpUpgradeFeature.UpgradeAsync was already called and can only be called once per connection.";
        internal static string BadRequest_RequestBodyTooLarge = "Request body too large.";
        internal static string MaxRequestBodySizeCannotBeModifiedAfterRead = "The maximum request body size cannot be modified after the app has already started reading from the request body.";
        internal static string MaxRequestBodySizeCannotBeModifiedForUpgradedRequests = "The maximum request body size cannot be modified after the request has been upgraded.";
        internal static string PositiveTimeSpanRequired = "Value must be a positive TimeSpan.";
        internal static string NonNegativeTimeSpanRequired = "Value must be a non-negative TimeSpan.";
        internal static string FormatMinimumGracePeriodRequired(double heartbeatInterval) => $"The request body rate enforcement grace period must be greater than {heartbeatInterval} second.";
        internal static string SynchronousReadsDisallowed = "Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead.";
        internal static string SynchronousWritesDisallowed = "Synchronous operations are disallowed. Call WriteAsync or set AllowSynchronousIO to true instead.";
        internal static string PositiveNumberOrNullMinDataRateRequired = "Value must be a positive number. To disable a minimum data rate, use null where a MinDataRate instance is expected.";
        internal static string ConcurrentTimeoutsNotSupported = "Concurrent timeouts are not supported.";
        internal static string PositiveFiniteTimeSpanRequired = "Timespan must be positive and finite.";
        internal static string EndPointRequiresAtLeastOneProtocol = "An endpoint must be configured to serve at least one protocol.";
        internal static string EndPointHttp2NotNegotiated = "HTTP/2 over TLS was not negotiated on an HTTP/2-only endpoint.";
        internal static string FormatHPackErrorDynamicTableSizeUpdateTooLarge(int size, int maxSize) => $"A dynamic table size of {size} octets is greater than the configured maximum size of {maxSize} octets.";
        internal static string FormatHPackErrorIndexOutOfRange(int index) => $"Index {index} is outside the bounds of the header field table.";
        internal static string HPackHuffmanErrorIncomplete = "Input data could not be fully decoded.";
        internal static string HPackHuffmanErrorEOS = "Input data contains the EOS symbol.";
        internal static string HPackHuffmanErrorDestinationTooSmall = "The destination buffer is not large enough to store the decoded data.";
        internal static string HPackHuffmanError = "Huffman decoding error.";
        internal static string FormatHPackStringLengthTooLarge(int length, int maxStringLength) => $"Decoded string length of {length} octets is greater than the configured maximum length of {maxStringLength} octets.";
        internal static string HPackErrorIncompleteHeaderBlock = "The header block was incomplete and could not be fully decoded.";
        internal static string FormatHttp2ErrorStreamIdEven(Http2FrameType frameType, int streamId) => $"The client sent a {frameType} frame with even stream ID {streamId}.";
        internal static string Http2ErrorPushPromiseReceived = "The client sent a A PUSH_PROMISE frame.";
        internal static string FormatHttp2ErrorHeadersInterleaved(Http2FrameType frameType, int streamId, int headersStreamId) => $"The client sent a {frameType} frame to stream ID {streamId} before signaling of the header block for stream ID {headersStreamId}.";
        internal static string FormatHttp2ErrorStreamIdZero(Http2FrameType frameType) => $"The client sent a {frameType} frame with stream ID 0.";
        internal static string FormatHttp2ErrorStreamIdNotZero(Http2FrameType frameType) => $"The client sent a {frameType} frame with stream ID different than 0.";
        internal static string FormatHttp2ErrorPaddingTooLong(Http2FrameType frameType) => $"The client sent a {frameType} frame with padding longer than or with the same length as the sent data.";
        internal static string FormatHttp2ErrorStreamClosed(Http2FrameType frameType, int streamId) => $"The client sent a {frameType} frame to closed stream ID {streamId}.";
        internal static string FormatHttp2ErrorStreamHalfClosedRemote(Http2FrameType frameType, int streamId) => $"The client sent a {frameType} frame to stream ID {streamId} which is in the \"half-closed(remote) state\".";
        internal static string FormatHttp2ErrorStreamSelfDependency(Http2FrameType frameType, int streamId) => $"The client sent a {frameType} frame with dependency information that would cause stream ID {streamId} to depend on itself.";
        internal static string FormatHttp2ErrorUnexpectedFrameLength(Http2FrameType frameType, int expectedLength) => $"The client sent a {frameType} frame with length different than {expectedLength}.";
        internal static string Http2ErrorSettingsLengthNotMultipleOfSix = "The client sent a SETTINGS frame with a length that is not a multiple of 6.";
        internal static string Http2ErrorSettingsAckLengthNotZero = "The client sent a SETTINGS frame with ACK set and length different than 0.";
        internal static string FormatHttp2ErrorSettingsParameterOutOfRange(Http2SettingsParameter parameter) => $"The client sent a SETTINGS frame with a value for parameter {parameter} that is out of range.";
        internal static string Http2ErrorWindowUpdateIncrementZero = "The client sent a WINDOW_UPDATE frame with a window size increment of 0.";
        internal static string Http2ErrorContinuationWithNoHeaders = "The client sent a CONTINUATION frame not preceded by a HEADERS frame.";
        internal static string FormatHttp2ErrorStreamIdle(Http2FrameType frameType, int streamId) => $"The client sent a {frameType} frame to idle stream ID {streamId}.";
        internal static string Http2ErrorTrailersContainPseudoHeaderField = "The client sent trailers containing one or more pseudo-header fields.";
        internal static string Http2ErrorHeaderNameUppercase = "The client sent a header with uppercase characters in its name.";
        internal static string Http2ErrorTrailerNameUppercase = "The client sent a trailer with uppercase characters in its name.";
        internal static string Http2ErrorHeadersWithTrailersNoEndStream = "The client sent a HEADERS frame containing trailers without setting the END_STREAM flag.";
        internal static string Http2ErrorMissingMandatoryPseudoHeaderFields = "Request headers missing one or more mandatory pseudo-header fields.";
        internal static string Http2ErrorPseudoHeaderFieldAfterRegularHeaders = "Pseudo-header field found in request headers after regular header fields.";
        internal static string Http2ErrorUnknownPseudoHeaderField = "Request headers contain unknown pseudo-header field.";
        internal static string Http2ErrorResponsePseudoHeaderField = "Request headers contain response-specific pseudo-header field.";
        internal static string Http2ErrorDuplicatePseudoHeaderField = "Request headers contain duplicate pseudo-header field.";
        internal static string Http2ErrorConnectionSpecificHeaderField = "Request headers contain connection-specific header field.";
        internal static string UnableToConfigureHttpsBindings = "Unable to configure default https bindings because no IDefaultHttpsProvider service was provided.";
        internal static string AuthenticationFailed = "Failed to authenticate HTTPS connection.";
        internal static string AuthenticationTimedOut = "Authentication of the HTTPS connection timed out.";
        internal static string FormatInvalidServerCertificateEku(string thumbprint) => $"Certificate {thumbprint} cannot be used as an SSL server certificate. It has an Extended Key Usage extension but the usages do not include Server Authentication (OID 1.3.6.1.5.5.7.3.1).";
        internal static string PositiveTimeSpanRequired1 = "Value must be a positive TimeSpan.";
        internal static string ServerCertificateRequired = "The server certificate parameter is required.";
        internal static string BindingToDefaultAddresses = "No listening endpoints were configured. Binding to {address0} and {address1} by default.";
        internal static string FormatCertNotFoundInStore(string subject, StoreLocation storeLocation, string storeName, bool allowInvalid) => $"The requested certificate {subject} could not be found in {storeLocation}/{storeName} with AllowInvalid setting: {allowInvalid}.";
        internal static string FormatEndpointMissingUrl(string endpointName) => $"The endpoint {endpointName} is missing the required 'Url' parameter.";
        internal static string NoCertSpecifiedNoDevelopmentCertificateFound = "Unable to configure HTTPS endpoint. No server certificate was specified, and the default developer certificate could not be found or is out of date.To generate a developer certificate run 'dotnet dev-certs https'. To trust the certificate(Windows and macOS only) run 'dotnet dev-certs https --trust'.For more information on configuring HTTPS see https://go.microsoft.com/fwlink/?linkid=848054.";
        internal static string FormatMultipleCertificateSources(string endpointName) => $"The endpoint {endpointName} specified multiple certificate sources.";
        internal static string WritingToResponseBodyAfterResponseCompleted = "Cannot write to the response body, the response has completed.";
        internal static string BadRequest_RequestBodyTimeout = "Reading the request body timed out due to data arriving too slowly. See MinRequestBodyDataRate.";
        internal static string ConnectionAbortedByApplication = "The connection was aborted by the application.";
        internal static string ConnectionAbortedDuringServerShutdown = "The connection was aborted because the server is shutting down and request processing didn't complete within the time specified by HostOptions.ShutdownTimeout.";
        internal static string ConnectionTimedBecauseResponseMininumDataRateNotSatisfied = "The connection was timed out by the server because the response was not read by the client at the specified minimum data rate.";
        internal static string ConnectionTimedOutByServer = "The connection was timed out by the server.";
        internal static string FormatHttp2ErrorFrameOverLimit(int size, uint limit) => $"The received frame size of {size} exceeds the limit {limit}.";
        internal static string FormatHttp2ErrorMinTlsVersion(SslProtocols protocol) => $"Tls 1.2 or later must be used for HTTP/2. {protocol} was negotiated.";
        internal static string Http2ErrorInvalidPreface = "Invalid HTTP/2 connection preface.";
        internal static string InvalidEmptyHeaderName = "Header name cannot be a null or empty string.";
        internal static string ConnectionOrStreamAbortedByCancellationToken = "The connection or stream was aborted because a write operation was aborted with a CancellationToken.";
        internal static string Http2ErrorInitialWindowSizeInvalid = "The client sent a SETTINGS frame with a SETTINGS_INITIAL_WINDOW_SIZE that caused a flow-control window to exceed the maximum size.";
        internal static string Http2ErrorWindowUpdateSizeInvalid = "The client sent a WINDOW_UPDATE frame that caused a flow-control window to exceed the maximum size.";
        internal static string Http2ConnectionFaulted = "The HTTP/2 connection faulted.";
        internal static string Http2StreamResetByClient = "The client reset the request stream.";
        internal static string Http2StreamAborted = "The request stream was aborted.";
        internal static string Http2ErrorFlowControlWindowExceeded = "The client sent more data than what was available in the flow-control window.";
        internal static string Http2ErrorConnectMustNotSendSchemeOrPath = "CONNECT requests must not send :scheme or :path headers.";
        internal static string FormatHttp2ErrorMethodInvalid(string method) => $"The Method '{method}' is invalid.";
        internal static string FormatHttp2StreamErrorPathInvalid(string path) => "The request :path is invalid: '{path}'";
        internal static string FormatHttp2StreamErrorSchemeMismatch(string requestScheme, string transportScheme) => $"The request :scheme header '{requestScheme}' does not match the transport scheme '{transportScheme}'.";
        internal static string Http2StreamErrorLessDataThanLength = "Less data received than specified in the Content-Length header.";
        internal static string Http2StreamErrorMoreDataThanLength = "More data received than specified in the Content-Length header.";
        internal static string Http2StreamErrorAfterHeaders = "An error occurred after the response headers were sent, a reset is being sent.";
        internal static string Http2ErrorMaxStreams = "A new stream was refused because this connection has reached its stream limit.";
        internal static string GreaterThanZeroRequired = "A value greater than zero is required.";
        internal static string FormatArgumentOutOfRange(uint min, uint max) => $"A value between {min} and {max} is required.";
        internal static string HPackErrorDynamicTableSizeUpdateNotAtBeginningOfHeaderBlock = "Dynamic tables size update did not occur at the beginning of the first header block.";
        internal static string HPackErrorNotEnoughBuffer = "The given buffer was too small to encode any headers.";
        internal static string HPackErrorIntegerTooBig = "The decoded integer exceeds the maximum value of Int32.MaxValue.";
        internal static string ConnectionAbortedByClient = "The client closed the connection.";
        internal static string FormatHttp2ErrorStreamAborted(Http2FrameType frameType, int streamId) => $"A frame of type {frameType} was received after stream {streamId} was reset or aborted.";
        internal static string ProtocolSelectionFailed = "HTTP protocol selection failed.";
        internal static string ServerShutdownDuringConnectionInitialization = "Server shutdown started during connection initialization.";
        internal static string StartAsyncBeforeGetMemory = "Cannot call GetMemory() until response has started. Call HttpResponse.StartAsync() before calling GetMemory().";
        internal static string Http2MinDataRateNotSupported = "This feature is not supported for HTTP/2 requests except to disable it entirely by setting the rate to null.";
        internal static string RequestTrailersNotAvailable = "The request trailers are not available yet. They may not be available until the full request body is read.";
        internal static string HTTP2NoTlsOsx = "HTTP/2 over TLS is not supported on macOS due to missing ALPN support.";
        internal static string HTTP2NoTlsWin7 = "HTTP/2 over TLS is not supported on Windows 7 due to missing ALPN support.";
        internal static string FormatHttp2StreamResetByApplication(Http2ErrorCode errorCode) => $"The HTTP/2 stream was reset by the application with error code {errorCode}.";
        internal static string Http2TellClientToCalmDown = "A new stream was refused because this connection has too many streams that haven't finished processing. This may happen if many streams are aborted but not yet cleaned up.";
        internal static string BadDeveloperCertificateState = "The ASP.NET Core developer certificate is in an invalid state. To fix this issue, run the following commands 'dotnet dev-certs https --clean' and 'dotnet dev-certs https' to remove all existing ASP.NET Core development certificates and create a new untrusted developer certificate. On macOS or Windows, use 'dotnet dev-certs https --trust' to trust the new certificate.";
    }
}

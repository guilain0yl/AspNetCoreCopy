using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text;

namespace Microsoft.AspNetCore.Mvc.Core
{
    internal class Resources
    {
        internal static string FormatMatchAllContentTypeIsNotAllowed(string s0) => string.Format("The argument '{0}' is invalid. Media types which match all types or match all subtypes are not supported.", s0);
        internal static string FormatObjectResult_MatchAllContentType(string s0, string s1) => string.Format("The content-type '{0}' added in the '{1}' property is invalid. Media types which match all types or match all subtypes are not supported.", s0, s1);
        internal static string FormatActionExecutor_WrappedTaskInstance(string s0, string s1, string s2) => string.Format("The method '{0}' on type '{1}' returned an instance of '{2}'. Make sure to call Unwrap on the returned value to avoid unobserved faulted Task.", s0, s1, s2);
        internal static string FormatActionExecutor_UnexpectedTaskInstance(string s0, string s1) => string.Format("The method '{0}' on type '{1}' returned a Task instance even though it is not an asynchronous method.", s0, s1);
        internal static string FormatActionInvokerFactory_CouldNotCreateInvoker(string s0) => string.Format("An action invoker could not be created for action '{0}'.", s0);
        internal static string FormatActionDescriptorMustBeBasedOnControllerAction(Type s0) => string.Format("The action descriptor must be of type '{0}'.", s0);
        internal static string ArgumentCannotBeNullOrEmpty = "Value cannot be null or empty.";
        internal static string FormatPropertyOfTypeCannotBeNull(string s0, Type s1) => string.Format("The '{0}' property of '{1}' must not be null.", s0, s1);
        internal static string FormatPropertyOfTypeCannotBeNull(Type s0, string s1) => string.Format("The '{0}' property of '{1}' must not be null.", s0, s1);

        internal static string FormatPropertyOfTypeCannotBeNull(string s0, string s1) => string.Format("The '{0}' property of '{1}' must not be null.", s0, s1);
        internal static string FormatTypeMethodMustReturnNotNullValue(string s0, string s1) => string.Format("The '{0}' method of type '{1}' cannot return a null value.", s0, s1);
        internal static string FormatModelBinding_NullValueNotValid(string s0) => string.Format("The value '{0}' is invalid.", s0);
        internal static string FormatInvalid_IncludePropertyExpression(ExpressionType s0) => string.Format("The passed expression of expression node type '{0}' is invalid. Only simple member access expressions for model properties are supported.", s0);
        internal static string NoRoutesMatched = "No route matches the supplied values.";
        internal static string FormatAsyncActionFilter_InvalidShortCircuit(string s0, string s1, string s2, string s3) => string.Format("If an {0} provides a result value by setting the {1} property of {2} to a non-null value, then it cannot call the next filter by invoking {3}.", s0, s1, s2, s3);
        internal static string FormatAsyncResultFilter_InvalidShortCircuit(string s0, string s1, string s2, string s3) => string.Format("If an {0} cancels execution by setting the {1} property of {2} to 'true', then it cannot call the next filter by invoking {3}.", s0, s1, s2, s3);
        internal static string FormatFilterFactoryAttribute_TypeMustImplementIFilter(string s0, string s1) => string.Format("The type provided to '{0}' must implement '{1}'.", s0, s1);
        internal static string FormatActionResult_ActionReturnValueCannotBeNull(Type s0) => string.Format("Cannot return null from an action method with a return type of '{0}'.", s0);
        internal static string FormatTypeMustDeriveFromType(string s0, string s1) => string.Format("The type '{0}' must derive from '{1}'.", s0, s1);
        internal static string FormatInputFormatterNoEncoding(string s0) => string.Format("No encoding found for input formatter '{0}'. There must be at least one supported encoding registered in order for the formatter to read content.", s0);
        internal static string FormatUnsupportedContentType(string s0) => string.Format("Unsupported content type '{0}'.", s0);
        internal static string FormatOutputFormatterNoMediaType(string s0) => string.Format("No supported media type registered for output formatter '{0}'. There must be at least one supported media type registered in order for the output formatter to write content.", s0);
        internal static string FormatAttributeRoute_AggregateErrorMessage(string s0, string s1) => string.Format("The following errors occurred with attribute routing information:{0}{0}{1}", s0, s1);
        internal static string FormatAttributeRoute_CannotContainParameter(string s0, string s1, string s2) => string.Format("The attribute route '{0}' cannot contain a parameter named '{{{1}}}'. Use '[{1}]' in the route template to insert the value '{2}'.", s0, s1, s2);
        internal static string FormatAttributeRoute_IndividualErrorMessage(string s0, string s1, string s2) => string.Format("For action: '{0}'{1}Error: {2}", s0, s1, s2);
        internal static string AttributeRoute_TokenReplacement_EmptyTokenNotAllowed = "An empty replacement token ('[]') is not allowed.";
        internal static string AttributeRoute_TokenReplacement_ImbalancedSquareBrackets = "Token delimiters ('[', ']') are imbalanced.";
        internal static string FormatAttributeRoute_TokenReplacement_InvalidSyntax(string s0, string s1) => string.Format("The route template '{0}' has invalid syntax. {1}", s0, s1);
        internal static string FormatAttributeRoute_TokenReplacement_ReplacementValueNotFound(string s0, string s1, string s2) => string.Format("While processing template '{0}', a replacement value for the token '{1}' could not be found. Available tokens: '{2}'. To use a '[' or ']' as a literal string in a route or within a constraint, use '[[' or ']]' instead.", s0, s1, s2);
        internal static string AttributeRoute_TokenReplacement_UnclosedToken = "A replacement token is not closed.";
        internal static string AttributeRoute_TokenReplacement_UnescapedBraceInToken = "An unescaped '[' token is not allowed inside of a replacement token. Use '[[' to escape.";
        internal static string FormatUnableToFindServices(string s0, string s1, string s2) => string.Format("Unable to find the required services. Please add all the required services by calling '{0}.{1}' inside the call to '{2}' in the application startup code.", s0, s1, s2);
        internal static string FormatAttributeRoute_DuplicateNames_Item(string s0, string s1) => string.Format("Action: '{0}' - Template: '{1}'", s0, s1);
        internal static string FormatAttributeRoute_DuplicateNames(string s0, string s1, string s2) => string.Format("Attribute routes with the same name '{0}' must have the same template:{1}{2}", s0, s1, s2);
        internal static string FormatAttributeRoute_AggregateErrorMessage_ErrorNumber(int s0, string s1, string s2) => string.Format("Error {0}:{1}{2}", s0, s1, s2);
        internal static string FormatAttributeRoute_MixedAttributeAndConventionallyRoutedActions_ForMethod(string s0, string s1, string s2) => string.Format("A method '{0}' must not define attribute routed actions and non attribute routed actions at the same time:{1}{2}{1}{1}Use 'AcceptVerbsAttribute' to create a single route that allows multiple HTTP verbs and defines a route, or set a route template in all attributes that constrain HTTP verbs.", s0, s1, s2);
        internal static string FormatAttributeRoute_MixedAttributeAndConventionallyRoutedActions_ForMethod_Item(string s0, string s1, string s2) => string.Format("Action: '{0}' - Route Template: '{1}' - HTTP Verbs: '{2}'", s0, s1, s2);
        internal static string AttributeRoute_NullTemplateRepresentation = "(none)";
        internal static string FormatDefaultActionSelector_AmbiguousActions(string s0, string s1) => string.Format("Multiple actions matched. The following actions matched route data and had all constraints satisfied:{0}{0}{1}", s0, s1);
        internal static string FormatFileResult_InvalidPath(string s0) => string.Format("Could not find file: {0}", s0);
        internal static string SerializableError_DefaultError = "The input was not valid.";
        internal static string FormatAsyncResourceFilter_InvalidShortCircuit(string s0, string s1, string s2, string s3) => string.Format("If an {0} provides a result value by setting the {1} property of {2} to a non-null value, then it cannot call the next filter by invoking {3}.", s0, s1, s2, s3);
        internal static string FormatResponseCache_SpecifyDuration(string s0, string s1) => string.Format("If the '{0}' property is not set to true, '{1}' property must be specified.", s0, s1);
        internal static string FormatApiExplorer_UnsupportedAction(string s0) => string.Format("The action '{0}' has ApiExplorer enabled, but is using conventional routing. Only actions which use attribute routing support ApiExplorer.", s0);
        internal static string FormatterMappings_NotValidMediaType => "The media type \"{0}\" is not valid. MediaTypes containing wildcards (*) are not allowed in formatter mappings.";
        internal static string Format_NotValid => "The format provided is invalid '{0}'. A format must be a non-empty file-extension, optionally prefixed with a '.' character.";
        internal static string FormatCacheProfileNotFound(string s0) => string.Format("The '{0}' cache profile is not defined.", s0);
        internal static string FormatModelType_WrongType(string s0, string s1) => string.Format("The model's runtime type '{0}' is not assignable to the type '{1}'.", s0, s1);
        internal static string FormatValueInterfaceAbstractOrOpenGenericTypesCannotBeActivated(string s0, string s1) => string.Format("The type '{0}' cannot be activated by '{1}' because it is either a value type, an interface, an abstract class or an open generic type.", s0, s1);
        internal static string FormatBinderType_MustBeIModelBinder(string s0, string s1) => string.Format("The type '{0}' must implement '{1}' to be used as a model binder.", s0, s1);
        internal static string FormatBindingSource_CannotBeComposite(string s0, string s1) => string.Format("The provided binding source '{0}' is a composite. '{1}' requires that the source must represent a single type of input.", s0, s1);
        internal static string FormatBindingSource_CannotBeGreedy(string s0, string s1) => string.Format("The provided binding source '{0}' is a greedy data source. '{1}' does not support greedy data sources.", s0, s1);
        internal static string FormatCommon_PropertyNotFound(Type s0, string s1) => string.Format("The property {0}.{1} could not be found.", s0, s1);
        internal static string FormatJQueryFormValueProviderFactory_MissingClosingBracket(string s0) => string.Format("The key '{0}' is invalid JQuery syntax because it is missing a closing bracket.", s0);
        internal static string KeyValuePair_BothKeyAndValueMustBePresent = "A value is required.";
        internal static string FormatModelBinderUtil_ModelCannotBeNull(string s0) => string.Format("The binding context has a null Model, but this binder requires a non-null model of type '{0}'.", s0);
        internal static string FormatModelBinderUtil_ModelInstanceIsWrong(string s0, string s1) => string.Format("The binding context has a Model of type '{0}', but this binder can only operate on models of type '{1}'.", s0, s1);
        internal static string ModelBinderUtil_ModelMetadataCannotBeNull = "The binding context cannot have a null ModelMetadata.";
        internal static string FormatModelBinding_MissingBindRequiredMember(string s0) => string.Format("A value for the '{0}' parameter or property was not provided.", s0);
        internal static string ModelBinding_MissingRequestBodyRequiredMember = "A non-empty request body is required.";
        internal static string FormatValueProviderResult_NoConverterExists(Type s0, Type s1) => string.Format("The parameter conversion from type '{0}' to type '{1}' failed because no type converter can convert between these types.", s0, s1);
        internal static string FormatFileResult_PathNotRooted(string s0) => string.Format("Path '{0}' was not rooted.", s0);
        internal static string UrlNotLocal = "The supplied URL is not local. A URL with an absolute path is considered local if it does not have a host/authority part. URLs using virtual paths ('~/') are also local.";
        internal static string FormatFormatFormatterMappings_GetMediaTypeMappingForFormat_InvalidFormat(string s0) => string.Format("The argument '{0}' is invalid. Empty or null formats are not supported.", s0);
        internal static string FormatAcceptHeaderParser_ParseAcceptHeader_InvalidValues(string s0) => string.Format("\"Invalid values '{0}'.\"", s0);
        internal static string FormatModelState_AttemptedValueIsInvalid(string s0, string s1) => string.Format("The value '{0}' is not valid for {1}.", s0, s1);
        internal static string FormatModelState_NonPropertyAttemptedValueIsInvalid(string s0) => string.Format("The value '{0}' is not valid.", s0);
        internal static string FormatModelState_UnknownValueIsInvalid(string s0) => string.Format("The supplied value is invalid for {0}.", s0);
        internal static string ModelState_NonPropertyUnknownValueIsInvalid = "The supplied value is invalid.";
        internal static string FormatHtmlGeneration_ValueIsInvalid(string s0) => string.Format("The value '{0}' is invalid.", s0);
        internal static string FormatHtmlGeneration_ValueMustBeNumber(string s0) => string.Format("The field {0} must be a number.", s0);
        internal static string HtmlGeneration_NonPropertyValueMustBeNumber = "The field must be a number.";
        internal static string FormatTextInputFormatter_SupportedEncodingsMustNotBeEmpty(string s0) => string.Format("The list of '{0}' must not be empty. Add at least one supported encoding.", s0);
        internal static string FormatTextOutputFormatter_SupportedEncodingsMustNotBeEmpty(string s0) => string.Format("The list of '{0}' must not be empty. Add at least one supported encoding.", s0);
        internal static string FormatTextOutputFormatter_WriteResponseBodyAsyncNotSupported(string s0, string s1, string s2) => string.Format("'{0}' is not supported by '{1}'. Use '{2}' instead.", s0, s1, s2);
        internal static string FormatFormatter_NoMediaTypes(string s0, string s1) => string.Format("No media types found in '{0}.{1}'. Add at least one media type to the list of supported media types.", s0, s1);
        internal static string FormatCouldNotCreateIModelBinder(Type s0) => string.Format("Could not create a model binder for model object of type '{0}'.", s0);
        internal static string FormatInputFormattersAreRequired(string s0, string s1, string s2) => string.Format("'{0}.{1}' must not be empty. At least one '{2}' is required to bind from the body.", s0, s1, s2);
        internal static string FormatModelBinderProvidersAreRequired(string s0, string s1, string s2) => string.Format("'{0}.{1}' must not be empty. At least one '{2}' is required to model bind.", s0, s1, s2);
        internal static string FormatOutputFormattersAreRequired(string s0, string s1, string s2) => string.Format("'{0}.{1}' must not be empty. At least one '{2}' is required to format a response.", s0, s1, s2);
        internal static string FormatMiddewareFilter_ConfigureMethodOverload(string s0) => string.Format("Multiple overloads of method '{0}' are not supported.", s0);
        internal static string FormatMiddewareFilter_NoConfigureMethod(string s0, string s1) => string.Format("A public method named '{0}' could not be found in the '{1}' type.", s0, s1);
        internal static string FormatMiddlewareFilterBuilder_NoMiddlewareFeature(string s0) => string.Format("Could not find '{0}' in the feature list.", s0);
        internal static string FormatMiddlewareFilterBuilder_NullApplicationBuilder(string s0) => string.Format("The '{0}' property cannot be null.", s0);
        internal static string FormatMiddlewareFilter_InvalidConfigureReturnType(string s0, string s1, string s2) => string.Format("The '{0}' method in the type '{1}' must have a return type of '{2}'.", s0, s1, s2);
        internal static string FormatMiddlewareFilter_ServiceResolutionFail(string s0, string s1, string s2, string s3) => string.Format("Could not resolve a service of type '{0}' for the parameter '{1}' of method '{2}' on type '{3}'.", s0, s1, s2, s3);
        internal static string FormatAuthorizeFilter_AuthorizationPolicyCannotBeCreated(string s0, string s1) => string.Format("An {0} cannot be created without a valid instance of {1}.", s0, s1);
        internal static string FormatFormCollectionModelBinder_CannotBindToFormCollection(string s0, string s1, string s2) => string.Format("The '{0}' cannot bind to a model of type '{1}'. Change the model type to '{2}' instead.", s0, s1, s2);
        internal static string FormatVaryByQueryKeys_Requires_ResponseCachingMiddleware(string s0) => string.Format("'{0}' requires the response cache middleware.", s0);
        internal static string FormatCandidateResolver_DifferentCasedReference(string s0) => string.Format("A duplicate entry for library reference {0} was found. Please check that all package references in all projects use the same casing for the same package references.", s0);
        internal static string FormatMiddlewareFilterConfigurationProvider_CreateConfigureDelegate_CannotCreateType(Type s0, string s1) => string.Format("Unable to create an instance of type '{0}'. The type specified in {1} must not be abstract and must have a parameterless constructor.", s0, s1);
        internal static string FormatArgument_InvalidOffsetLength(string s0, string s1) => string.Format("'{0}' and '{1}' are out of bounds for the string.", s0, s1);
        internal static string FormatComplexTypeModelBinder_NoParameterlessConstructor_ForType(string s0) => string.Format("Could not create an instance of type '{0}'. Model bound complex types must not be abstract or value types and must have a parameterless constructor.", s0);
        internal static string FormatComplexTypeModelBinder_NoParameterlessConstructor_ForProperty(string s0, string s1, string s2) => string.Format("Could not create an instance of type '{0}'. Model bound complex types must not be abstract or value types and must have a parameterless constructor. Alternatively, set the '{1}' property to a non-null value in the '{2}' constructor.", s0, s1, s2);
        internal static string FormatNoRoutesMatchedForPage(string s0) => string.Format("No page named '{0}' matches the supplied values.", s0);
        internal static string FormatUrlHelper_RelativePagePathIsNotSupported(string s0, string s1, string s2) => string.Format("The relative page path '{0}' can only be used while executing a Razor Page. Specify a root relative path with a leading '/' to generate a URL outside of a Razor Page. If you are using {1} then you must provide the current {2} to use relative pages.", s0, s1, s2);
        internal static string ValidationProblemDescription_Title = "One or more validation errors occurred.";
        internal static string FormatApiController_AttributeRouteRequired(string s0, string s1) => string.Format("Action '{0}' does not have an attribute route. Action methods on controllers annotated with {1} must be attribute routed.", s0, s1);
        internal static string VirtualFileResultExecutor_NoFileProviderConfigured = "No file provider has been configured to process the supplied file.";
        internal static string FormatApplicationPartFactory_InvalidFactoryType(Type s0, string s1, Type s2) => string.Format("Type {0} specified by {1} is invalid. Type specified by {1} must derive from {2}.", s0, s1, s2);
        internal static string FormatRelatedAssemblyAttribute_AssemblyCannotReferenceSelf(string s0, string s1) => string.Format("{0} specified on {1} cannot be self referential.", s0, s1);
        internal static string FormatRelatedAssemblyAttribute_CouldNotBeFound(string s0, string s1, string s2) => string.Format("Related assembly '{0}' specified by assembly '{1}' could not be found in the directory {2}. Related assemblies must be co-located with the specifying assemblies.", s0, s1, s2);
        internal static string FormatApplicationAssembliesProvider_DuplicateRelatedAssembly(string s0) => string.Format("Each related assembly must be declared by exactly one assembly. The assembly '{0}' was declared as related assembly by the following:", s0);
        internal static string FormatApplicationAssembliesProvider_RelatedAssemblyCannotDefineAdditional(string s0, string s1) => string.Format("Assembly '{0}' declared as a related assembly by assembly '{1}' cannot define additional related assemblies.", s0, s1);
        internal static string FormatComplexTypeModelBinder_NoParameterlessConstructor_ForParameter(string s0, string s1) => string.Format("Could not create an instance of type '{0}'. Model bound complex types must not be abstract or value types and must have a parameterless constructor. Alternatively, give the '{1}' parameter a non-null default value.", s0, s1);
        internal static string FormatApiController_MultipleBodyParametersFound(string s0, string s1, string s2, string s3) => string.Format("Action '{0}' has more than one parameter that was specified or inferred as bound from request body. Only one parameter per action may be bound from body. Inspect the following parameters, and use '{1}' to specify bound from query, '{2}' to specify bound from route, and '{3}' for parameters to be bound from body:", s0, s1, s2, s3);
        internal static string FormatApiConventionMustBeStatic(Type s0) => string.Format("API convention type '{0}' must be a static type.", s0);
        internal static string FormatInvalidTypeTForActionResultOfT(Type s0, string s1) => string.Format("Invalid type parameter '{0}' specified for '{1}'.", s0, s1);
        internal static string FormatApiConvention_UnsupportedAttributesOnConvention(string s0, string s1, string s2) => string.Format("Method {0} is decorated with the following attributes that are not allowed on an API convention method:{1}The following attributes are allowed on API convention methods: {2}.", s0, s1, s2);
        internal static string FormatApiConventionMethod_AmbiguousMethodName(string s0, Type s1) => string.Format("Method name '{0}' is ambiguous for convention type '{1}'. More than one method found with the name '{0}'.", s0, s1);
        internal static string FormatApiConventionMethod_NoMethodFound(string s0, Type s1) => string.Format("A method named '{0}' was not found on convention type '{1}'.", s0, s1);
        internal static string FormatValidationVisitor_ExceededMaxDepth(string s0, int? s1, Type s2) => string.Format("{0} exceeded the maximum configured validation depth '{1}' when validating type '{2}'.", s0, s1, s2);
        internal static string FormatValidationVisitor_ExceededMaxDepthFix(string s0, string s1) => string.Format("This may indicate a very deep or infinitely recursive object graph. Consider modifying '{0}.{1}' or suppressing validation on the model type.", s0, s1);
        internal static string FormatValidationVisitor_ExceededMaxPropertyDepth(string s0, int? s1, string s2, Type s3) => string.Format("{0} exceeded the maximum configured validation depth '{1}' when validating property '{2}' on type '{3}'.", s0, s1, s2, s3);
        internal static string ApiConventions_Title_400 = "Bad Request";
        internal static string ApiConventions_Title_401 = "Unauthorized";
        internal static string ApiConventions_Title_403 = "Forbidden";
        internal static string ApiConventions_Title_404 = "Not Found";
        internal static string ApiConventions_Title_406 = "Not Acceptable";
        internal static string ApiConventions_Title_409 = "Conflict";
        internal static string ApiConventions_Title_415 = "Unsupported Media Type";
        internal static string ApiConventions_Title_422 = "Unprocessable Entity";
        internal static string FormatReferenceToNewtonsoftJsonRequired(string s0, string s1, string s2, string s3, string s4) => string.Format("'{0}' requires a reference to '{1}'. Configure your application by adding a reference to the '{1}' package and calling '{2}.{3}' inside the call to '{4}' in the application startup code.", s0, s1, s2, s3, s4);
        internal static string FormatModelBinding_ExceededMaxModelBindingCollectionSize(string s0, string s1, string s2, int s3, Type s4) => string.Format("Collection bound to '{0}' exceeded {1}.{2} ({3}). This limit is a safeguard against incorrect model binders and models. Address issues in '{4}'. For example, this type may have a property with a model binder that always succeeds. See the {1}.{2} documentation for more information.", s0, s1, s2, s3, s4);
        internal static string FormatModelBinding_ExceededMaxModelBindingRecursionDepth(string s0, string s1, int s2, Type s3) => string.Format("Model binding system exceeded {0}.{1} ({2}). Reduce the potential nesting of '{3}'. For example, this type may have a property with a model binder that always succeeds. See the {0}.{1} documentation for more information.", s0, s1, s2, s3);
        internal static string FormatProperty_MustBeInstanceOfType(string s0, string s1, Type s2) => string.Format("Property '{0}.{1}' must be an instance of type '{2}'.", s0, s1, s2);
        public static string FormatObjectResultExecutor_MaxEnumerationExceeded(string s0, Type s1) => string.Format("'{0}' reached the configured maximum size of the buffer when enumerating a value of type '{1}'. This limit is in place to prevent infinite streams of 'IAsyncEnumerable<>' from continuing indefinitely. If this is not a programming mistake, consider ways to reduce the collection size, or consider manually converting '{1}' into a list rather than increasing the limit.", s0, s1);
        internal static string UnexpectedJsonEnd = "Unexcepted end when reading JSON.";
        internal static string ApiConventions_Title_500 = "An error occured while processing your request.";
        internal static string FormatFailedToReadRequestForm(string s0) => string.Format("Failed to read the request form. {0}", s0);
    }
}
